# API 設計基準書

## 目次
[[_TOC_]]

## 1. RESTful API
- **リソース指向**: APIはリソースに基づき設計し、HTTPメソッド（GET, POST, PUT, DELETE）を使用して操作する。
- **URI設計**: リソースのURIは意味的でわかりやすく、階層的に設計することが望ましい。
  - 例: `/api/v1/tasks`（タスクリソース）

## 2. ステータスコード
- **成功**: 
  - 200 OK（成功）
  - 201 Created（リソース作成）
- **クライアントエラー**:
  - 400 Bad Request（不正なリクエスト）
  - 404 Not Found（リソースが見つからない）
- **サーバーエラー**:
  - 500 Internal Server Error（サーバー内部エラー）

## 3. エラーハンドリング
- **統一されたエラーレスポンス**: エラー発生時は、統一されたフォーマットでレスポンスを返すこと。
  - 例:
    ```json
    {
      "error": {
        "code": "BAD_REQUEST",
        "message": "不正なリクエストです"
      }
    }
    ```
- **ログ記録**: エラー情報は適切にログへ記録すること。

## 4. バージョニング
- **URIバージョニング**: APIのバージョンはURIに含める。
  - 例: `/api/v1/tasks`
- **互換性の維持**: 新しいバージョンリリース時は、既存のクライアントとの互換性を確保することが求められる。

## 5. セキュリティ
- **認証**: OAuth2やJWTを使用し、APIへのアクセスに対する認証を行う。
- **認可**: リソースへのアクセスは適切に制限する。
- **HTTPSの使用**: 通信の暗号化を徹底するため、HTTPSを使用することが推奨される。

## 6. ドキュメンテーション
- **自動生成**: SwaggerやOpenAPIを活用し、APIドキュメントを自動生成すること。
- **サンプルリクエスト/レスポンス**: 各エンドポイントに対するサンプルリクエストとレスポンスを提供する。

## 7. 性能
- **キャッシング**: 頻繁にアクセスされるデータに対してキャッシュを導入し、パフォーマンスを最適化する。
- **負荷分散**: 負荷分散を考慮した設計を行う。

## 8. 非同期処理
- **非同期通信**: Kafkaを利用し、非同期でデータのやり取りを行う。
- **イベント駆動**: イベントの生成と消費により、非同期処理の流れを管理する。

## 9. ロギングとモニタリング
- **ロギング**: APIリクエスト、レスポンス、エラーに関する情報を一貫した形式でログに記録する。
- **モニタリング**: APIの稼働状況、パフォーマンス、エラーレートを監視するため、PrometheusやGrafanaなどのツールを使用する。
- **分散トレーシング**: マイクロサービス間のリクエスト追跡をJaegerやZipkinを用いて可視化し、問題箇所を特定する。

## 10. レートリミッティング
- **リクエスト制限**: サービスの過負荷やDDoS攻撃を防ぐため、ユーザーごとにリクエスト数を制限する。
- **適応制御**: ユーザーやリソースの重要度に応じて、異なるリミットを設定する。

## 11. トランザクション管理
- **ACID特性**: データベース操作が一貫性を持つように、ACID特性を維持すること。
- **分散トランザクション**: SAGAパターンや2PCを利用し、マイクロサービス間でのトランザクションを管理する。

## 12. APIゲートウェイ
- **集中管理**: KongやIstioなどのAPIゲートウェイを使用し、認証、認可、レートリミッティング、負荷分散を一元管理する。
- **セキュリティ強化**: APIゲートウェイを通してアクセス制御を行い、セキュリティを強化する。

## 13. データフォーマットと圧縮
- **データフォーマット**: APIのデータフォーマットには、JSONやXMLに加え、ProtobufやAvroなど効率的なフォーマットを採用する場合がある。
- **データ圧縮**: 帯域幅の節約を目的に、gzipなどの圧縮技術を使用する。
